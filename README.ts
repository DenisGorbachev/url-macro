#!/usr/bin/env -S deno run --allow-read --allow-run=bash,git,cargo --allow-net=docs.rs:443 --allow-env --allow-sys

import * as zx from "npm:zx"
import { z, ZodSchema, ZodTypeDef } from "https://deno.land/x/zod@v3.23.8/mod.ts"
import { assert, assertEquals } from "jsr:@std/assert@1.0.0"

const CargoTomlSchema = z.object({
  package: z.object({
    name: z.string().min(1),
    description: z.string().min(1),
    repository: z.string().url().min(1),
    metadata: z.object({
      details: z.object({
        title: z.string().min(1).optional(),
        tagline: z.string().optional(),
        summary: z.string().optional(),
        peers: z.array(z.string()).default([]).describe("Packages that should be installed alongside this package")
      }).default({}),
    }).default({}),
  }),
})

type CargoToml = z.infer<typeof CargoTomlSchema>

const CargoMetadataSchema = z.object({
  packages: z.array(z.object({
    name: z.string(),
    targets: z.array(z.object({
      name: z.string(),
    })),
  })),
})

type CargoMetadata = z.infer<typeof CargoMetadataSchema>

const RepoSchema = z.object({
  url: z.string().url(),
})

type Repo = z.infer<typeof RepoSchema>

const BadgeSchema = z.object({
  name: z.string().min(1),
  image: z.string().url(),
  url: z.string().url(),
})

type Badge = z.infer<typeof BadgeSchema>

const badge = (name: string, image: string, url: string): Badge => BadgeSchema.parse({name, url, image})

const dirname = import.meta.dirname;
if (!dirname) throw new Error("Cannot determine the current script dirname")

const $ = zx.$({ cwd: dirname })

// deno-lint-ignore no-explicit-any
const parse = <Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output>(schema: ZodSchema<Output, Def, Input>, input: zx.ProcessOutput) => schema.parse(JSON.parse(input.stdout))

const theCargoToml: CargoToml = parse(CargoTomlSchema, await $`yj -t < Cargo.toml`)
const { package: { name, description, metadata: { details } } }= theCargoToml
const title = details.title || description
const peers = details.peers
const theCargoMetadata: CargoMetadata = parse(CargoMetadataSchema, await $`cargo metadata --format-version 1`)
const thePackageMetadata = theCargoMetadata.packages.find((p) => p.name == name)
assert(thePackageMetadata, "Could not find package metadata")
const target = thePackageMetadata.targets[0]
assert(target, "Could not find package first target")
const docsUrl = `https://docs.rs/${name}`

// launch multiple promises in parallel
const doc2ReadmePromise = $`cargo doc2readme --template README.jl --target-name ${target.name} --out -`
const ghRepoPromise = $`gh repo view --json url`
const docsUrlPromise = fetch(docsUrl, {method:"HEAD"})

const doc = await doc2ReadmePromise
const docStr = doc.stdout.trim();

const repo: Repo = parse(RepoSchema, await ghRepoPromise)
assertEquals(repo.url, theCargoToml.package.repository)

const docsUrlHead = await docsUrlPromise
const docsUrlIs200 = docsUrlHead.status === 200

const badges: Badge[] = [
  badge("Build",  `${repo.url}/actions/workflows/ci.yml/badge.svg`, repo.url)
]
if (docsUrlIs200) {
  badges.push(badge("Documentation",  `https://docs.rs/${name}/badge.svg`, docsUrl))
}
const badgesStr = badges.map(({name, image, url}) => `[![${name}](${image})](${url})`).join("\n");

const titleSection = [
    badgesStr,
    docStr
].filter(s => s.length)

const cargoAddPackages = [name, ...peers];

const autogenerated = `
<!-- DO NOT EDIT -->
<!-- This file is automatically generated by README.ts. -->
<!-- Edit README.ts if you want to make changes. -->
`.trim()

console.info(`
${autogenerated}

# ${title}

${titleSection.join("\n\n")}

## Installation

\`\`\`shell
cargo add ${cargoAddPackages.join(" ")}
\`\`\`

## Gratitude

Like the project? [‚≠ê Star this repo](${repo.url}) on GitHub!

## License

[Apache License 2.0](LICENSE-APACHE) or [MIT License](LICENSE-MIT) at your option.

Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.
`.trim())
